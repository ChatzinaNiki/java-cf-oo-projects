package gr.aueb.cf.ch10.Project2;

public class MaxSubarray {

    public static int maxSubArray(int[] arr) {
        // Αν ο πίνακας είναι άδειος
        if (arr == null || arr.length == 0) return 0;

        // Αρχικοποίηση local και global μέγιστου
        int localMaximum = arr[0];
        int globalMaximum = arr[0];

        // Επανάληψη για τον πίνακα
        for (int i = 1; i < arr.length; i++) {
            // Υπολογισμός του τοπικού μέγιστου
            localMaximum = Math.max(arr[i], localMaximum + arr[i]);

            // Ενημέρωση του συνολικού μέγιστου αν το τοπικό μέγιστο είναι μεγαλύτερο
            if (localMaximum > globalMaximum) {
                globalMaximum = localMaximum;
            }
        }

        return globalMaximum;
    }

    public static void main(String[] args) {
        int[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println("Το μέγιστο άθροισμα υποπίνακα είναι: " + maxSubArray(arr));
    }
}

/**
 * (α) Περιγραφή Αλγορίθμου:
 * Ο αλγόριθμος χρησιμοποιεί μια προσέγγιση δυναμικού προγραμματισμού για να υπολογίσει το μέγιστο άθροισμα ενός υποπίνακα.
 * Η βασική ιδέα είναι να διατηρούμε το τρέχον τοπικό μέγιστο για κάθε θέση του πίνακα και να συγκρίνουμε αν το άθροισμα του υποπίνακα
 * που τελειώνει στην τρέχουσα θέση είναι μεγαλύτερο από το στοιχείο που επεξεργαζόμαστε μόνο του.
 * <p>
 * Βήματα:
 * <p>
 * Αρχικοποιούμε δύο μεταβλητές: μία για το τρέχον μέγιστο (localMaximum) και μία για το συνολικό μέγιστο (globalMaximum).
 * Διατρέχουμε τον πίνακα με μία επανάληψη.
 * Για κάθε στοιχείο, αποφασίζουμε αν θα το προσθέσουμε στο προηγούμενο τοπικό μέγιστο ή αν θα ξεκινήσουμε νέο υποπίνακα από αυτό
 * το στοιχείο.
 * Ενημερώνουμε το globalMaximum αν το localMaximum ξεπερνά την τρέχουσα τιμή του.
 * Στο τέλος της επανάληψης, το globalMaximum θα περιέχει το μέγιστο άθροισμα.
 * (γ) Απόδειξη Πολυπλοκότητας O(n):
 * Ο αλγόριθμος διατρέχει τον πίνακα μία μόνο φορά (με τη χρήση ενός for loop), και για κάθε στοιχείο υπολογίζει το τοπικό μέγιστο.
 * Δεν υπάρχει επιπλέον επανάληψη ή αναδρομή που να αυξάνει την πολυπλοκότητα.
 * <p>
 * Η πολυπλοκότητα του αλγορίθμου είναι O(n), καθώς εκτελούμε σταθερές πράξεις για κάθε στοιχείο του πίνακα και δεν υπάρχουν εσωτερικές
 * επαναλήψεις.
 * <p>
 * Σχήματα (από την εικόνα που ανέβασες):
 * Στην πρώτη εικόνα, βλέπουμε τη διαδικασία υπολογισμού του τοπικού μέγιστου από αριστερά προς τα δεξιά. Καθώς προχωράμε στον πίνακα,
 * ενημερώνουμε το τοπικό μέγιστο και παρακολουθούμε το συνολικό μέγιστο. Για παράδειγμα, στη θέση arr[5], το τοπικό μέγιστο είναι το
 * άθροισμα των 3 προηγούμενων θέσεων, ενώ στη θέση arr[6], το τοπικό μέγιστο ενημερώνεται σε 5.
 */